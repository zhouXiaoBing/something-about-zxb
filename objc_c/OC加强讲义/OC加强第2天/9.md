##2、【掌握】autorelease的应用场景
##### 1、autorelease的应用场景
* 经常用来在类方法中快速创建1个对象。
```objc
// 声明实现一个类方法
 + (Student *)student
{
    // 在里面直接进行autorelease
    return [[[Student alloc] init] autorelease];
}
```
* 应用：
```objc
// 在自动释放池中使用类方法创建对象
@autoreleasepool{
 // 此时创建出来的对象不用关注释放问题。
  Student *s = [Student student];
}
```
* 错误写法：

 ```objc
 int main(){
 // 在自动释放池中使用类方法创建对象
 @autoreleasepool{

 }
 // 写在自动释放池外部将无法释放对象。
  Student *s = [Student student];
  reutrn 0;
 }
 ```
#####2、完善快速创建对象的方法

* 问题1：如果定1个GoodStudent，继承自Student,此时，还能使用类方法快速创建对象吗？

 * 解决方案：
   * 在类方法中使用id

   ```objc
   + (id)student
{
    return [[[Student alloc] init] autorelease];
}
```
`此时，返回的对象仍旧是Student.所以，应该用self，替代Student.`
* 问题2：用其他对象类型，接受自定义对象类型。
* 如：
        NSString *s = [Student student];
        NSLog(@"%lu",s.length);
`这段代码，编译时，不会报任何警告，但是运行时会直接崩溃。`
* 改进办法：

  ```objc
  //instancetype：可以动态判断返回的类型和接受的类型是否一致
  + (instancetype)student{

    return [[self alloc] init];
}
```
* 此时，编译器会警告
        NSString *s = [Student student];
        NSLog(@"%lu",s.length);

