## 主要知识点####1. 内存管理概念理解####2. 引用计数器####3. dealloc方法####4. 多对象内存管理####5. @property的修饰关键字####6. @class用法####7. 内存管理时的循环retain问题####8. 对象自动释放池的使用## 知识点细节####1. 内存管理的范围* 所有的OC对象(继承自NSObject类)####2. 为什么内存管理只管理OC对象? * 堆中内存不连续, 无法自动释放####3. 我们如何对OC对象进行内存管理? * 通过操作对象的"引用计数器"####4. 引用计数器* 什么是引用计数器? * 1> 每个OC对象都有自己的引用计数器 * 2> 它是一个整数(long类型, 占用8个字节) * 3> 从字面上, 可以理解为"对象被引用的次数" * 4> 也可以理解为: 它表示有多少人正在用这个对象* 引用计数器的作用?  * 1> 系统通过"引用计数器"来判断当前对象是否可以被释放* 对象的"引用计数器"的操作方式   * 1> retain, +1  * 2> release, -1  * 3> retainCount, 获取对象引用计数器的值####5. 关闭ARC的方法* 选中项目 -> 选中Build Settings -> 选中All -> 搜索 Automatic Reference Counting -> 修改为No####6. dealloc方法* 当对象即将被销毁, 系统自动给对象发送一条dealloc消息* 因此, 从dealloc方法有没有被调用, 就可以判断出对象是否被销毁* 重写了dealloc方法, 必须调用[super dealloc], 并且放在最后面调用 * 不要自己直接调用dealloc方法####7. 野指针\空指针\僵尸对象* 僵尸对象: 已经被销毁的对象(不能再使用的对象)* 野指针: 指向僵尸对象(不可用内存)的指针* 空指针: 没有指向存储空间的指针(里面存的是nil, 也就是0) * 注意: 给空指针发消息是没有任何反应的, 不会提示出错 nil Nil NULL [NSNULL null];####8. 开启僵尸对象监控* Edit Scheme -> Diagnostics -> Enable Zombie Objects####9. 多对象内存管理 * set方法的内存管理```objc -(void)setCar:(Car*)car{    if( _car != car){       [_car release];       _car = [car retain];} }}```* dealloc方法的内存管理 ```objc-(void)dealloc{   [_car release];   [super dealloc];}```####10. 苹果官方的内存管理原则:* 谁创建谁release, 如果你通过alloc、new或copy、mutableCopy来创建一个对象, 那么你必须调用release或autorelease* 谁retain谁release, 只要你调用了retain, 就必须调用一次release####11. @property的修饰关键字1> 控制set方法的内存管理* retain: release旧值,retain新值(用于OC对象),要配合nonatomic使用 * assign: 直接赋值,不做任何内存管理(默认,用于非OC对象类型)* copy: release旧值, copy新值(一般用于NSString *)2> 控制是否需要生成set方法* readwrite: 同时生成set方法和get方法(默认)  * readonly: 只会生成get方法3> 多线程管理* atomic: 性能低(默认)* nonatomic: 性能高(为iOS系统开发软件建议使用,为mac开发软件可以使用atomic)4> 控制set方法和get方法的名称* setter: 设置set方法的名称, 一定有个冒号: * getter: 设置get方法的名称####12. @class用法* 为什么要使用@class .h * 通过@class解决循环依赖问题####13. 内存管理时的循环retain问题* 解决办法: 一端用retain、一端用assign* 注意: 使用了assign后, dealloc中就不需要release了
